package main

import (
	"fmt"
	pkg2 "zadachki/algoExamplesPatterns/patterns/01_Facade/pkg"
)

/*
	Реализовать паттерн «фасад».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Facade_pattern
*/

/*
Фасад - паттерн, структурирующий объекты.
Предоставляет унифицированный интерфейс вместо набора интерфейсов некоторой подсистемы.
Фасад определяет интерфейс более высокого уровня, который упрощает использование подсистемы.

Применимость паттерна:
- когда необходимо предоставить простой интерфейс к сложной подсистеме;
- когда между клиентами и классами реализации абстракции существует много зависимостей;
- когда необходимо разложить подсистему на отдельные слои.

Плюсы:
- изолирует клиентов от компонентов подсистемы, уменьшая тем самым число объектов,
с которыми клиентам приходится иметь дело, и упрощая работу с подсистемой;
- позволяет ослабить связанность между подсистемой и ее клиентами;
- фасад не препятствует приложениям напрямую обращаться к классам подсистемы, если это необходимо.

Минусы:
- фасад обеспечивает только ограниченный набор функций, тем самы получаем менее гибкий код;


Примеры использования:
- Функция оплаты в интернет маркетплейсе WildBerries / Ozon.
*/

// Инициализация банка, двух карт, двух пользователей, одного продукта и магазина с этим продуктом.
var (
	bank = pkg2.Bank{
		Name:  "Банк",
		Cards: []pkg2.Card{},
	}

	card1 = pkg2.Card{
		Name:    "CARD-1",
		Balance: 200,
		Bank:    &bank,
	}

	card2 = pkg2.Card{
		Name:    "CARD-2",
		Balance: 5,
		Bank:    &bank,
	}

	user = pkg2.User{
		Name: "Андрей",
		Card: &card1,
	}

	user2 = pkg2.User{
		Name: "Андриана",
		Card: &card2,
	}

	prod = pkg2.Product{
		Name:  "Сыр",
		Price: 150,
	}

	shop = pkg2.Shop{
		Name: "SHOP",
		Products: []pkg2.Product{
			prod,
		},
	}
)

func main() {
	// В данном примере функция структуры магазина Sell является неким фасадом,
	// за которым происходит углубленный вызов другой бизнес логики.
	// В этом примере это легко проследить так как каждая функция пишет о своём вызове,
	// указывая структуру к которой она принадлежит.

	println("[Банк] Выпуск карт")

	// Добавление карт в слайс банка
	bank.Cards = append(bank.Cards, card1, card2)
	fmt.Printf("[%s]\n", user.Name)

	err := shop.Sell(user, prod.Name)
	if err != nil {
		println(err.Error())
		return
	}

	fmt.Printf("[%s]\n", user2.Name)

	err = shop.Sell(user2, prod.Name)
	if err != nil {
		println(err.Error())
		return
	}

}
